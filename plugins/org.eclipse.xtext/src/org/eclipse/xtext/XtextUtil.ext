/*******************************************************************************
 * Copyright (c) 2008 itemis AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/

import ecore;
import xtext;
import xtextutil; 

extension org::eclipse::xtend::util::stdlib::io;
extension org::eclipse::xtext::Extensions;

cached List[MetaModel] getAllMetaModels(Grammar this) :
	let x =  allMetamodelDeclarations().getMetaModel(this) :
		x.remove(null) ->
		setAbstractFeature(this,x) -> x;
		
theCurrentType(Action this) :
	getAllMetaModels(grammar())->
	currentType(this,grammar());

/* just for testing */
testCurrentType(RuleCall this) :
	getAllMetaModels(grammar())->
	currentType(this,grammar());
	
private AbstractType typeForName(Grammar this, String name) :
	getAllMetaModels().select(mm|mm.alias()==name.getAlias()).first().types.select(e|e.name == name.getTypeName()).first();

private MetaModel getMetaModel(AbstractMetamodelDeclaration this, Grammar concreteGrammar) : error("");

private create MetaModel getMetaModel(GeneratedMetamodel gmm, Grammar concreteGrammar) :
	setDeclaration(gmm) ->
	types.addAll(getTypes(gmm,concreteGrammar))
;

private create MetaModel getMetaModel(ReferencedMetamodel rmm, Grammar concreteGrammar) :
	setDeclaration(rmm) ->
	types.addAll(getTypes(rmm,concreteGrammar))
;

private Set[AbstractType] getTypes(AbstractMetamodelDeclaration this, Grammar concreteGrammar) :
	concreteGrammar.allParserRules().getReturnTypeName().select(s|s.getAlias()==alias).createComplexType(concreteGrammar)
	.union(
		concreteGrammar.allLexerRules().getReturnTypeName().select(s|s.getAlias()==alias).createDataType(concreteGrammar)
	).union(
		concreteGrammar.containedActions().typeName.getQualifiedName().select(s|s.getAlias()==alias).createComplexType(concreteGrammar)	
	).toSet()
;

private DataType createOrGetBoolean(Grammar this) :
	let type = createDataType("ecore::EBoolean",this) :
		allMetamodelDeclarations().select(e|e.alias=='ecore').first().getMetaModel(this).types.add(type) ->
		type;

private create ComplexType createComplexType(String name, Grammar g) :
	setName(name.getTypeName()) ->
	superTypes.addAll(findSuperTypes(this,g)) ->
	features.addAll(createOrUpdateFeatures(this,g))
;


private setAbstractFeature(Grammar this, List[MetaModel] x) :
	x.types.flatten().typeSelect(ComplexType).collect(e|e.setAbstract((e.isAbstract(this))));

private cached Boolean isAbstract(ComplexType name, Grammar g) :
	g.eAllContents.typeSelect(Action).select(e|e.typeName.getQualifiedName() == name.getQualifiedName()).isEmpty &&
	g.eAllContents.typeSelect(Assignment).select(e|(if e.currentType(g)==null then info(e)) -> (e.currentType(g).getQualifiedName()) == (name.getQualifiedName())).isEmpty
;
		
	
private Set[ComplexType] findSuperTypes(ComplexType type, Grammar g) :
	g.eAllContents
		.select(e|e.currentType(g)==type && e.currentType(g) != e.containingParserRule().currentType(g))
		.collect(e|e.containingParserRule().currentType(g)).toSet().remove(null);

// Feature creation

private Set[Feature] createOrUpdateFeatures(ComplexType type, Grammar g) :
	g.eAllContents.createOrUpdateFeature(type,g).toSet().remove(null);
	
private Feature createOrUpdateFeature(emf::EObject this, ComplexType typeName, Grammar g) : null;
private Feature createOrUpdateFeature(Action this, ComplexType typeName, Grammar g) : 
	if (this.currentType(g) == typeName) then
		createFeature(this.feature, typeName, g).update(this,g)
;
private Feature createOrUpdateFeature(Assignment this, ComplexType typeName, Grammar g) :
	if (this.currentType(g) == typeName) then
		createFeature(this.feature, typeName, g).update(this,g)
;

private create Feature createFeature(String feature, ComplexType typename, Grammar g) :
	setName(feature)
;

private Feature update(Feature this, Assignment that, Grammar g) :
	(
		if that.operator == '?=' then (
			setType(g.createOrGetBoolean())
		) else (
			switch (that.operator) {
				case '+=': setUpperBound(-1)
				case '=': setUpperBound(1)
				default : null
			} -> 
			this.setType(returnType(that.terminal,g)) ->
			this.setContainment(that.eAllContents.typeSelect(CrossReference).isEmpty)
		)
	)
	-> this
;

private Feature update(Feature this, Action that, Grammar g) :
	(
		switch (that.operator) {
			case '+=': setUpperBound(-1)
			case '=': setUpperBound(1)
			default : null
		} -> 
		this.setType(currentType(that.eContainer,g)) ->
		this.setContainment(true)
	)
	-> this
;

private create DataType createDataType(String name, Grammar g) :
	setName(name.getTypeName());
// returnType
private cached AbstractType returnType(Void this, Grammar g) : null; 
private cached AbstractType returnType(CrossReference this, Grammar g) : createComplexType(getQualifiedName(this.type),g); 
private cached AbstractType returnType(AbstractElement this, Grammar g) : error("") -> null;	
private cached AbstractType returnType(Alternatives this, Grammar g) : groups.returnType(g).toSet().toList().first();	
private cached AbstractType returnType(RuleCall this, Grammar g) : 
	returnType(calledRule(),g);

private cached AbstractType returnType(Keyword this, Grammar g) : 
	typeForName(g,"ecore::EString");

private cached ComplexType returnType(AbstractRule this, Grammar g) : error("");	

private cached ComplexType returnType(ParserRule this, Grammar g) :
	this.getReturnTypeName().createComplexType(g);	

private cached DataType returnType(LexerRule this, Grammar g) :
	this.getReturnTypeName().createDataType(g);	

// end returnType

// currentType
private cached AbstractType currentType(Void this, Grammar g) : null; 
private AbstractType currentType(emf::EObject this, Grammar g) :
	if RuleCall.isInstance(this) && !((RuleCall)this).isAssigned() then (
		(returnType(calledRule((RuleCall)this),g))
	) else (
		let containmentList = eContainer.eContents:
			let index = containmentList.indexOf(this) :
				if index==0 then
					currentType(eContainer,g)
				else 
					currentType(getLastChild(containmentList.get(index - 1)),g)
	)
;
				
private cached emf::EObject getLastChild(emf::EObject this) :
	if this!=null then (
		if eContents.isEmpty then (
			this
		) else (
			getLastChild(eContents.last())
		) 
	)
;
	
private cached ComplexType currentType(AbstractRule this, Grammar g) : error("");	

private cached ComplexType currentType(Action this, Grammar g) : 
	this.typeName.getQualifiedName().createComplexType(g);	

private cached ComplexType currentType(ParserRule this, Grammar g) :
	getReturnTypeName().createComplexType(g);	

private cached DataType currentType(LexerRule this, Grammar g) :
	this.getReturnTypeName().createDataType(g);	


// end currentType

cached getQualifiedName(AbstractType this) :
	(metaModel.alias() == null ? "" : metaModel.alias()+"::")+name;

// serialize

info(MetaModel this) : info(ser()) -> this;

ser(MetaModel this) :
	'metamodel '+alias()+'{'
	+types.ser().toString("\n")+'}';
	
ser(AbstractType this) :
	'datatype '+getQualifiedName();

ser(ComplexType this) :
	(abstract?'abstract ':'')+'type '+getQualifiedName()+ '{'
		+features.ser().toString("\n")+
	'}';
	
ser(Feature this) :
	name+" "+(type==null?'null':type.getQualifiedName())+"["+lowerBound+","+upperBound+"]";


