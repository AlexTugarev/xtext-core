/*******************************************************************************
 * Copyright (c) 2009 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.xtext.xtext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.*;
import org.eclipse.xtext.conversion.IValueConverterService;
import org.eclipse.xtext.conversion.ValueConverterException;
import org.eclipse.xtext.parsetree.AbstractNode;
import org.eclipse.xtext.parsetree.NodeUtil;
import org.eclipse.xtext.util.XtextSwitch;
import org.eclipse.xtext.validation.AbstractDeclarativeValidator;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.inject.Inject;

/**
 * @author Sebastian Zarnekow - Initial contribution and API
 */
public class XtextValidator extends AbstractDeclarativeValidator {

	@Override
	protected List<? extends EPackage> getEPackages() {
		return Collections.singletonList(XtextPackage.eINSTANCE);
	}

	@Check(CheckType.FAST)
	public void checkGrammarUsesMaxOneOther(final Grammar grammar) {
		assertTrue("You may not use more than one other grammar.", XtextPackage.GRAMMAR__USED_GRAMMARS, grammar
				.getUsedGrammars().size() <= 1);
	}

	@Check
	public void checkGrammarName(final Grammar g) {
		final String[] split = g.getName().split("\\.");
		if (split.length == 1) {
			warning("You should use a namespace.", XtextPackage.GRAMMAR__NAME);
		}
		for (int i = 0; i < split.length - 1; i++) {
			final String nsEle = split[i];
			if (Character.isUpperCase(nsEle.charAt(0))) {
				warning("Namespace elements should start with a lower case letter.", XtextPackage.GRAMMAR__NAME);
			}
		}
		final String ele = split[split.length - 1];
		if (!Character.isUpperCase(ele.charAt(0))) {
			error("The last element should start with an upper case letter.", XtextPackage.GRAMMAR__NAME);
		}
	}

	@Check
	public void checkGeneratedMetamodel(final GeneratedMetamodel metamodel) {
		if (metamodel.getName() != null && metamodel.getName().length() != 0)
			if (Character.isUpperCase(metamodel.getName().charAt(0))) {
				warning("Metamodel names should start with a lower case letter.",
						XtextPackage.GENERATED_METAMODEL__NAME);
			}
	}

	@Inject
	private IValueConverterService valueConverter;

	@Check
	public void checkReferencedMetamodel(final ReferencedMetamodel metamodel) throws ValueConverterException {
		if (metamodel.getEPackage() == null)
			return;
		final String nsURI = metamodel.getEPackage().getNsURI();
		final List<GeneratedMetamodel> allGeneratedMetamodels = new ArrayList<GeneratedMetamodel>();
		final Grammar grammar = GrammarUtil.getGrammar(metamodel);
		final Set<Grammar> visited = Sets.newHashSet();
		for (final Grammar usedGrammar : grammar.getUsedGrammars()) {
			Iterables.addAll(allGeneratedMetamodels, getAllGeneratedMetamodels(usedGrammar, visited));
		}
		if (allGeneratedMetamodels.isEmpty())
			return;
		final List<AbstractNode> nodes = NodeUtil.findNodesForFeature(metamodel,
				XtextPackage.Literals.ABSTRACT_METAMODEL_DECLARATION__EPACKAGE);
		if (nodes.size() != 1)
			throw new IllegalArgumentException();
		String text = nodes.get(0).serialize();
		text = (String) valueConverter.toValue(text, "STRING", nodes.get(0));
		for (final GeneratedMetamodel generatedMetamodel : allGeneratedMetamodels) {
			final EPackage generatedPackage = generatedMetamodel.getEPackage();
			if (generatedPackage != null && nsURI.equals((generatedPackage.getNsURI()))) {
				assertEquals("Metamodels that have been generated by a super grammar must be referenced by nsURI: "
						+ nsURI, XtextPackage.ABSTRACT_METAMODEL_DECLARATION__EPACKAGE, text, nsURI);
			}
		}
	}

	private Iterable<GeneratedMetamodel> getAllGeneratedMetamodels(final Grammar grammar, final Set<Grammar> visited) {
		Iterable<GeneratedMetamodel> result = Iterables.filter(grammar.getMetamodelDeclarations(),
				GeneratedMetamodel.class);
		for (final Grammar gr : grammar.getUsedGrammars()) {
			if (visited.add(gr)) {
				result = Iterables.concat(result, getAllGeneratedMetamodels(gr, visited));
			}
		}
		return result;
	}

	@Check
	public void checkMetamodelUris(final AbstractMetamodelDeclaration declaration) {
		guard(declaration.getEPackage().getNsURI() != null);

		final Grammar grammar = GrammarUtil.getGrammar(declaration);
		final Iterable<String> nsUris = Iterables.transform(grammar.getMetamodelDeclarations(),
				new Function<AbstractMetamodelDeclaration, String>() {
					public String apply(final AbstractMetamodelDeclaration param) {
						if (param.getEPackage() != null)
							return param.getEPackage().getNsURI();
						return null;
					}
				});
		final int count = Iterables.size(Iterables.filter(nsUris, new Predicate<String>() {
			public boolean apply(final String param) {
				return declaration.getEPackage().getNsURI().equals(param);
			}
		}));
		assertTrue("EPackage with ns-uri '" + declaration.getEPackage().getNsURI() + "' is used twice.",
				XtextPackage.ABSTRACT_METAMODEL_DECLARATION__EPACKAGE, count == 1);
	}

	@Check
	public void checkCrossReferenceTerminal(final CrossReference reference) {
		if (reference.getTerminal() != null && !(reference.getTerminal() instanceof RuleCall)) {
			warning("Your grammar will not work with the default linking implementation, "
					+ "because Alternatives are currently not handled properly in CrossReferences.",
					XtextPackage.CROSS_REFERENCE__TERMINAL);
		}
	}

	@Check
	public void checkRuleName(final AbstractRule rule) {
		final Grammar grammar = GrammarUtil.getGrammar(rule);
		final TreeSet<String> foundNames = new TreeSet<String>();
		for (final AbstractRule otherRule : GrammarUtil.allRules(grammar)) {
			if (rule.getName().equalsIgnoreCase(otherRule.getName()) && rule != otherRule) {
				foundNames.add(otherRule.getName());
			}
		}
		if (!foundNames.isEmpty()) {
			final String message = "Rulename has to be unique even case insensitive.";
			if (foundNames.size() == 1) {
				error(message + "\nOther rule was: " + foundNames.first(), XtextPackage.ABSTRACT_RULE__NAME);
			}
			else {
				final StringBuilder builder = new StringBuilder((rule.getName().length() + 2) * foundNames.size() - 2);
				for (final String name : foundNames) {
					if (builder.length() != 0) {
						builder.append(", ");
					}
					builder.append(name);
				}
				error(message + "\nOther rules were: " + builder + ".", XtextPackage.ABSTRACT_RULE__NAME);
			}
		}
	}

	@Check
	public void checkUnassignedActionAfterAssignment(final Action action) {
		if (action.getFeature() == null) {
			checkCurrentMustBeUnassigned(action);
		}
	}

	@Check
	public void checkUnassignedRuleCallAllowed(final RuleCall call) {
		if (call.getRule() != null && GrammarUtil.containingAssignment(call) == null) {
			final AbstractRule container = EcoreUtil2.getContainerOfType(call, AbstractRule.class);
			if (call.getRule() instanceof ParserRule) {
				if (container instanceof TerminalRule) {
					error("Cannot call parser rule from terminal rule.", null);
				}
				else if (!GrammarUtil.isDatatypeRule((ParserRule) call.getRule())) {
					checkCurrentMustBeUnassigned(call);
				}
			}
		}
	}

	private void checkCurrentMustBeUnassigned(final AbstractElement element) {
		final ParserRule rule = GrammarUtil.containingParserRule(element);
		if (GrammarUtil.isDatatypeRule(rule))
			return;
		final XtextSwitch<Boolean> visitor = new XtextSwitch<Boolean>() {
			private boolean isNull = true;

			@Override
			public Boolean caseAbstractElement(final AbstractElement object) {
				return isNull;
			}

			@Override
			public Boolean caseAlternatives(final Alternatives object) {
				final boolean wasIsNull = isNull;
				boolean localIsNull = wasIsNull;
				for (final AbstractElement element : object.getGroups()) {
					isNull = wasIsNull;
					localIsNull &= doSwitch(element);
				}
				isNull = localIsNull;
				return isNull;
			}

			@Override
			public Boolean caseAssignment(final Assignment object) {
				isNull = false;
				return isNull;
			}

			@Override
			public Boolean caseGroup(final Group object) {
				for (final AbstractElement element : object.getTokens()) {
					doSwitch(element);
				}
				return isNull;
			}

			@Override
			public Boolean caseAction(final Action object) {
				if (object == element) {
					assertTrue("An unassigned action is not allowed, when the 'current' was already created.", null,
							isNull && !isMany(object));
					checkDone();
				}
				isNull = false;
				return isNull;
			}

			@Override
			public Boolean caseRuleCall(final RuleCall object) {
				if (object == element) {
					assertTrue("An unassigned rule call is not allowed, when the 'current' was already created.", null,
							isNull && !isMany(object));
					checkDone();
				}
				return doSwitch(object.getRule());
			}

			@Override
			public Boolean caseParserRule(final ParserRule object) {
				isNull = false;
				return isNull;
			}

			@Override
			public Boolean caseTerminalRule(final TerminalRule object) {
				isNull = false;
				return isNull;
			}

			public boolean isMany(final AbstractElement element) {
				return GrammarUtil.isMultipleCardinality(element)
						|| ((element.eContainer() instanceof AbstractElement) && isMany((AbstractElement) element
								.eContainer()));
			}

		};
		visitor.doSwitch(rule.getAlternatives());
	}

	@Check
	public void checkAssignedActionAfterAssignment(final Action action) {
		if (action.getFeature() != null) {
			final ParserRule rule = GrammarUtil.containingParserRule(action);
			final XtextSwitch<Boolean> visitor = new XtextSwitch<Boolean>() {
				private boolean assignedActionAllowed = false;

				@Override
				public Boolean caseAbstractElement(final AbstractElement object) {
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseAlternatives(final Alternatives object) {
					final boolean wasActionAllowed = assignedActionAllowed;
					boolean localActionAllowed = true;
					for (final AbstractElement element : object.getGroups()) {
						assignedActionAllowed = wasActionAllowed;
						localActionAllowed &= doSwitch(element);
					}
					assignedActionAllowed = wasActionAllowed
							|| (localActionAllowed && !GrammarUtil.isOptionalCardinality(object));
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseAssignment(final Assignment object) {
					assignedActionAllowed = assignedActionAllowed || !GrammarUtil.isOptionalCardinality(object);
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseGroup(final Group object) {
					final boolean wasAssignedActionAllowed = assignedActionAllowed;
					for (final AbstractElement element : object.getTokens()) {
						doSwitch(element);
					}
					assignedActionAllowed = wasAssignedActionAllowed
							|| (assignedActionAllowed && !GrammarUtil.isOptionalCardinality(object));
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseAction(final Action object) {
					if (object == action) {
						assertTrue("An action is not allowed, when the current may still be unassigned.", null,
								assignedActionAllowed);
						checkDone();
					}
					assignedActionAllowed = true;
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseRuleCall(final RuleCall object) {
					assignedActionAllowed = assignedActionAllowed || doSwitch(object.getRule())
							&& !GrammarUtil.isOptionalCardinality(object);
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseParserRule(final ParserRule object) {
					assignedActionAllowed = !GrammarUtil.isDatatypeRule(object);
					return assignedActionAllowed;
				}

				@Override
				public Boolean caseTerminalRule(final TerminalRule object) {
					return assignedActionAllowed;
				}

			};
			visitor.doSwitch(rule.getAlternatives());
		}
	}

	@Check
	public void checkEnumLiteralIsUnique(final EnumLiteralDeclaration decl) {
		final EnumRule rule = GrammarUtil.containingEnumRule(decl);
		final List<EnumLiteralDeclaration> declarations = EcoreUtil2.getAllContentsOfType(rule,
				EnumLiteralDeclaration.class);
		final String literal = decl.getLiteral().getValue();
		for (final EnumLiteralDeclaration otherDecl : declarations) {
			if (otherDecl != decl && literal.equals(otherDecl.getLiteral().getValue())) {
				error("Enum literal '" + literal + "' is used multiple times in enum rule '" + rule.getName() + "'.",
						XtextPackage.ENUM_LITERAL_DECLARATION__LITERAL);
			}
		}
	}

	@Check
	public void checkGeneratedEnumIsValid(final EnumLiteralDeclaration decl) {
		final EnumRule rule = GrammarUtil.containingEnumRule(decl);
		guard(rule.getType().getMetamodel() instanceof GeneratedMetamodel);
		final List<EnumLiteralDeclaration> declarations = EcoreUtil2.getAllContentsOfType(rule,
				EnumLiteralDeclaration.class);
		final EEnum eEnum = (EEnum) rule.getType().getClassifier();
		guard(declarations.size() != eEnum.getELiterals().size());
		for (final EnumLiteralDeclaration otherDecl : declarations) {
			if (decl == otherDecl)
				return;
			if (otherDecl.getEnumLiteral() == decl.getEnumLiteral()) {
				if (!decl.getEnumLiteral().getLiteral().equals(decl.getLiteral().getValue())) {
					warning("Enum literal '" + decl.getEnumLiteral().getName()
							+ "' has already been defined with literal '" + decl.getEnumLiteral().getLiteral() + "'.",
							XtextPackage.ENUM_LITERAL_DECLARATION__ENUM_LITERAL);
				}
				return;
			}
		}
	}

	@Check
	public void checkEnumLiteralIsValid(final EnumLiteralDeclaration decl) {
		if ("".equals(decl.getLiteral().getValue())) {
			error("Enum literal must not be an empty string.", XtextPackage.ENUM_LITERAL_DECLARATION__LITERAL);
		}
	}

}
