/*******************************************************************************
* Copyright (c) 2008 itemis AG and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
* committers of openArchitectureWare - initial API and implementation
*******************************************************************************/

import ecore;
import xtext;
import xtextutil; 

extension org::eclipse::xtext::Extensions;
extension org::eclipse::xtext::GrammarUtil;

/*
context Action ERROR "Created class " + typeName.name + " cannot be resolved" :
	resolveCreatedType() != null;
	
context Action if resolveCreatedType() != null ERROR "Created class does not inherit from the rule's return type" :
	!resolveCreatedType().referenced() 
	|| ((EClass) containingParserRule().resolveReturnType().eClassifier).isSuperTypeOf((EClass) resolveCreatedType().eClassifier);
*/

context RuleCall ERROR "Couldn't resolve called rule "+name :
	calledRule()!=null;

context GeneratedMetamodel ERROR "Only one generated metamodel can have default alias" :
	alias != null
	|| alias != ""
	|| grammar().metamodelDeclarations.typeSelect(GeneratedMetamodel).select(gmm|gmm.alias == null || gmm.alias =="").size == 1;

context GeneratedMetamodel ERROR "Duplicate aliases are only allowed for referenced metamodels" :
	grammar().metamodelDeclarations.typeSelect(GeneratedMetamodel).select(gmm|gmm.alias == alias).size == 1;

context AbstractRule ERROR "Name must be unique" :
	grammar().rules.select(p | p.name == name).size==1;
	
// TODO: check that CrossReferences can only appear inside Assignments

/*
context ParserRule ERROR "Returned class " + getReturnTypeName() + " cannot be resolved" :
	resolveReturnType() != null;
	
// referenced EPackages must not contain duplicate classifiers

context ReferencedMetamodel ERROR "Metamodels with same alias must not have a classifier in common" :
	loadMetaModel().ePackage.eClassifiers.name.intersect(
		grammar().referencedMetamodels().select(mm|mm.alias==alias && mm.declaration != this).ePackage.eClassifiers.name.flatten()).isEmpty;
*/
